Compliant Solution (redirectErrorStream())
This compliant solution redirects the process's error stream to its output stream. Consequently, the program can empty the single output stream without fear of blockage.

public class Exec {
  public static void main(String args[])
                          throws IOException, InterruptedException {
    ProcessBuilder pb = new ProcessBuilder("notemaker");
    pb = pb.redirectErrorStream(true);
    Process proc = pb.start();
    InputStream is = proc.getInputStream();
    int c;
    while ((c = is.read()) != -1) {
      System.out.print((char) c);
    }
    int exitVal = proc.waitFor();
  }
}

Compliant Solution (Process Output Stream and Error Stream)
This compliant solution spawns two threads to consume the process's output stream and error stream. Consequently, the process cannot block indefinitely on those streams.
When the output and error streams are handled separately, they must be emptied independently. Failure to do so can cause the program to block indefinitely.

class StreamGobbler extends Thread {
  InputStream is;
  PrintStream os;
 
  StreamGobbler(InputStream is, PrintStream os) {
    this.is = is;
    this.os = os;
  }
 
  public void run() {
    try {
      int c;
      while ((c = is.read()) != -1)
          os.print((char) c);
    } catch (IOException x) {
      // Handle error
    }
  }
}
 
public class Exec {
  public static void main(String[] args)
    throws IOException, InterruptedException {
 
    Runtime rt = Runtime.getRuntime();
    Process proc = rt.exec("notemaker");
 
    // Any error message?
    StreamGobbler errorGobbler =
        new StreamGobbler(proc.getErrorStream(), System.err);
 
    // Any output?
    StreamGobbler outputGobbler =
        new StreamGobbler(proc.getInputStream(), System.out);
 
    errorGobbler.start();
    outputGobbler.start();
 
    // Any error?
    int exitVal = proc.waitFor();
    errorGobbler.join();   // Handle condition where the
    outputGobbler.join();  // process ends before the threads finish
  }
}
